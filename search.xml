<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android中的倒计时]]></title>
    <url>%2F2018%2F06%2F13%2FAndroid%E4%B8%AD%E7%9A%84%E5%80%92%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[第一种方式 CountDownTimerCountDownTimer的使用12345678910111213CountDownTimer timer = new CountDownTimer(5000, 1000) &#123; @Override public void onTick(long l) &#123; Log.i(&quot;TAG&quot;, &quot;Millisecond:&quot;+ l); Log.i(&quot;TAG&quot;, &quot;Second:&quot;+ l/1000+&quot;&quot;); &#125; @Override public void onFinish() &#123; Log.i(&quot;TAG&quot;, &quot;Finish&quot;); &#125; &#125;; timer.start(); 由于CountDownTimer在内部使用了handler所以在Activity退出时需要销毁,否则容易造成内测泄露1234567@Override protected void onDestroy() &#123; super.onDestroy(); if(timer != null)&#123; timer.cancel(); &#125; &#125; 使用CountDownTimer造成的误差在使用上方代码开始倒计时时，会发现存在误差的情况，Log打印日志如下：123456789101106-13 22:11:32.666 27136-27136/com.example.potato.tcptext1 I/TAG: Millisecond:494506-13 22:11:32.666 27136-27136/com.example.potato.tcptext1 I/TAG: Second:406-13 22:11:33.667 27136-27136/com.example.potato.tcptext1 I/TAG: Millisecond:394406-13 22:11:33.667 27136-27136/com.example.potato.tcptext1 I/TAG: Second:306-13 22:11:34.669 27136-27136/com.example.potato.tcptext1 I/TAG: Millisecond:294106-13 22:11:34.670 27136-27136/com.example.potato.tcptext1 I/TAG: Second:206-13 22:11:35.671 27136-27136/com.example.potato.tcptext1 I/TAG: Millisecond:194006-13 22:11:35.671 27136-27136/com.example.potato.tcptext1 I/TAG: Second:106-13 22:11:36.672 27136-27136/com.example.potato.tcptext1 I/TAG: Millisecond:93806-13 22:11:36.673 27136-27136/com.example.potato.tcptext1 I/TAG: Second:006-13 22:11:37.612 27136-27136/com.example.potato.tcptext1 I/TAG: Finish 最开始的5最不见了，而且毫秒数也不是1000的整数，于是通过查看源码发现造成的原因：123456789101112131415161718192021222324252627282930313233···mStopTimeInFuture = SystemClock.elapsedRealtime() + mMillisInFuture;······final long millisLeft = mStopTimeInFuture - SystemClock.elapsedRealtime();if (millisLeft &lt;= 0) &#123; onFinish();&#125; else &#123; long lastTickStart = SystemClock.elapsedRealtime(); onTick(millisLeft); // take into account user&apos;s onTick taking time to execute long lastTickDuration = SystemClock.elapsedRealtime() - lastTickStart; long delay; if (millisLeft &lt; mCountdownInterval) &#123; // just delay until done delay = millisLeft - lastTickDuration; // special case: user&apos;s onTick took more than interval to // complete, trigger onFinish without delay if (delay &lt; 0) delay = 0; &#125; else &#123; delay = mCountdownInterval - lastTickDuration; // special case: user&apos;s onTick took more than interval to // complete, skip to next interval while (delay &lt; 0) delay += mCountdownInterval; &#125;&#125;··· 发现调用start方法后，CountDownTimer并不是直接把我们设置的时间当作倒计时开始时间，而且加上了SystemClock.elapsedRealtime()，也就是系统启动到现在的时间。而在handler中又减去了SystemClock.elapsedRealtime()，说明中间的过程把handler所消耗的时间都计算在内，所以造成了我们多看到的偏差，也很好的解释onTick返回的不是整数秒的原因。 所以修改以上代码，开始计时加上一个误差值，使得毫秒数/1000 为正确需要显示的值123456789101112timer = new CountDownTimer(5500, 1000) &#123; @Override public void onTick(long l) &#123; Log.i(&quot;TAG&quot;, &quot;Millisecond:&quot;+ l); Log.i(&quot;TAG&quot;, &quot;Second:&quot;+ l/1000+&quot;&quot;); &#125; @Override public void onFinish() &#123; Log.i(&quot;TAG&quot;, &quot;Finish&quot;); &#125; &#125;; ChronometerXML布局12345&lt;Chronometer android:id=&quot;@+id/chronometer&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; /&gt; 代码设置chronometer.setBase(SystemClock.elapsedRealtime()); //还可以通过setFormat来设置时间格式 chronometer.start(); //设置监听 chronometer.setOnChronometerTickListener(new Chronometer.OnChronometerTickListener() { @Override public void onChronometerTick(Chronometer chronometer) { //计时5秒 if(SystemClock.elapsedRealtime() - chronometer.getBase() &gt;5000){ chronometer.stop(); Log.i(&quot;TAG&quot;, &quot;Finish&quot;); } } });]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PopupWindow的使用]]></title>
    <url>%2F2018%2F06%2F11%2FPopupWindow%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[PopupWindow 构造方法1234public PopupWindow (Context context)public PopupWindow (View contentView)public PopupWindow (View contentView, int width, int height)public PopupWindow (View contentView, int width, int height, boolean focusable) 其中contentView为PopupWindow要显示的View，width和height为view的宽度和高度 PopupWindow 设置视图12345public void setContentView (View contentView);//例如View view = LayoutInflater.from(this).inflate(R.layout.layout, null);mPopupWindow.setContentView(view); PopupWindow 大小123456public void setWidth (int width);public void setHeight (int height);//例如mPopupWindow.setWidth(LayoutParams.WRAP_CONTENT);mPopupWindow.setHeight(LayoutParams.WRAP_CONTENT); 如果需要设置PopupWindows的大小为屏幕的固定比例：1234567//获取屏幕宽高方法DisplayMetrics dm = new DisplayMetrics();getWindowManager().getDefaultDisplay().getMetrics(dm);int height = (int) (dm.heightPixels * 0.6);int width = dm.widthPixels;mPopupWindow.setWidth(width);mPopupWindow.setHeight(height); PopupWindow 其他设置12345//设置背景（有时候会出现黑边，可以用此方法解决）mPopupWindow.setBackgroundDrawable(null);//点击空白处让PopupWindow消失mPopupWindow.setOutsideTouchable(true); PopupWindow 显示默认提供以下几种方法：123showAsDropDown(View anchor);showAsDropDown(View anchor, int xoff, int yoff);showAsDropDown(View anchor, int xoff, int yoff, int gravity); 相对于组件 弹窗位于anchor的正下方 如果指定了xoff和yoff，则会在原有位置向右偏移xoff，向下偏移yoff。 如果指定gravity为Gravity.RIGHT，则弹窗和控件右对齐；否则左对齐。注意，计算右对齐时使用了- PopupWindow的宽度，如果指定的宽度不是固定值，则计算会失效（可以从源码中看出来）。 1showAtLocation(View parent, int gravity, int x, int y) 相对于parent屏幕 parent可以为Activity中的任意一个View，会通过该View找到父Window gravity: 在parent中的位置 x,y: 表示距离Window边缘的距离，方向由Gravity决定。例如：设置了Gravity.TOP，则y表示与Window上边缘的距离；而如果设置了Gravity.BOTTOM，则y表示与下边缘的距离。 例如 PopupWindow 显示在屏幕的底部：1mPopupWindow.showAtLocation(layoutAll, Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL, 0, 0); PopupWindow 空白处变暗123456789101112//设置手机屏幕亮度变暗public static void lightoff(Context context) &#123; WindowManager.LayoutParams lp = ((Activity)context).getWindow().getAttributes(); lp.alpha = 0.3f; ((Activity)context).getWindow().setAttributes(lp);&#125;//设置手机屏幕亮度正常public static void lighton(Context context) &#123; WindowManager.LayoutParams lp = ((Activity)context).getWindow().getAttributes(); lp.alpha = 1f; ((Activity)context).getWindow().setAttributes(lp); &#125; 在PopupWindow显示的时候调用lightoff(Context context)方法就可以让屏幕变暗 在PopupWindow消失的时候调用lighton(Context context)方法就可以让屏幕显示正常 设置PopupWindow监听（消失时调用lightoff）123456mPopupWindow.setOnDismissListener(new PopupWindow.OnDismissListener() &#123; @Override public void onDismiss() &#123; lighton(MainActivity.this); &#125; &#125;); 重写返回键123456789@Overridepublic void onBackPressed() &#123; if (popupWindow.isShowing()) &#123; mPopupWindow.dismiss(); lighton(this); &#125; else &#123; finish(); &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 6.0+ 动态权限Permission]]></title>
    <url>%2F2018%2F04%2F01%2FPermission%2F</url>
    <content type="text"><![CDATA[需要申请的权限表 Permission Group Permissions CALENDAR READ_CALENDARWRITE_CALENDAR CAMERA CAMERA CONTACTS READ_CONTACTSWRITE_CONTACTSGET_ACCOUNTS LOCATION ACCESS_FINE_LOCATIONACCESS_COARSE_LOCATION MICROPHONE RECORD_AUDIO PHONE READ_PHONE_STATEREAD_PHONE_NUMBERSCALL_PHONEANSWER_PHONE_CALLS (must request at runtime)READ_CALL_LOGWRITE_CALL_LOGADD_VOICEMAILUSE_SIPPROCESS_OUTGOING_CALLSANSWER_PHONE_CALLSREAD_PHONE_NUMBERS SENSORS BODY_SENSORS SMS SEND_SMSRECEIVE_SMSREAD_SMSRECEIVE_WAP_PUSHRECEIVE_MMS STORAGE READ_EXTERNAL_STORAGEWRITE_EXTERNAL_STORAGE 以上权限需要动态申请（当targetSdkVersion &gt;= 23 时） 检查是否有权限1ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) 申请权限12ActivityCompat.requestPermissions(this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1002) 申请回调12345678910111213141516@Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1002: if(grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; //申请成功将执行的操作 &#125;else&#123; Toast.makeText(this, "需要申请存储权限", Toast.LENGTH_SHORT).show(); &#125; break; &#125; super.onRequestPermissionsResult(requestCode, permissions, grantResults); &#125; 1, 2 步完整代码1234567if(ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1002); &#125;else&#123; //申请成功将执行的操作 &#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Hexo博客]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[第一次建立博客的记录 第一步 下载node.js并安装 下载Git并安装 下载安装Hexo(npm install -g hexo) 第二步 建立GitHub Pages New repository -&gt; 你的Github用户名.github.io 作为仓库名 第三步 创建本地文件 新建一个文件夹，以Blog为例 在文件夹目录下右键选择Git Bash Here，并输入hexo init（初始化博客） 运行 hexo server，此时可以通过输入地址localhost:4000访问博客 第四步 关联GitHub Pages 打开Blog目录下的_config.yml配置文件，在末尾加入以下代码 1234deploy: type: git repository: https://github.com/123/123.github.io.git branch: master https://github.com/123/123.github.io.git 为你刚刚新建仓库的链接 注意以上代码的格式 所有：之后都要加一个空格 type，repository，branch 3个标签之前加2个空格 输入 1npm install hexo-deployer-git --save 输入 123hexo clean hexo g hexo d 现在就可以登上 xxxx.github.io 访问你的博客了 更换主题(Next主题) 下载主题（进入themes目录） 1git clone https://github.com/iissnan/hexo-theme-next.git 打开__config.yml文件，将themes修改为下载到的主题文件夹的名字,比如 1theme: next 修改主题的语言，在__config.yml文件的最上方修改（简体中文） 1language: zh-Hans 运行输入 12hexo ghexo d 上传博客 在文件夹目录下，使用Git命令输入 1hexo new &quot;标题&quot; 在/source/_posts下会生成对应的.md文件，在该.md文件中编写你的博客（使用MakeDown语法） 编写完成后，运行 12hexo g hexo d 可以在生成本地文件时运行 hexo clean 用来清除本地缓存文件]]></content>
      <tags>
        <tag>建站</tag>
      </tags>
  </entry>
</search>
